<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Don't Touch The Floor!</title>
  
  <!-- Using Bungee font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet" />

  <style>
    /* High Scores Table */
    #highScoresWrapper {
      margin-top: 20px;
    }
    #highScoresWrapper h3 {
      margin: 10px 0 6px;
      font-size: 1.6em;
      color: #fff;
    }
    table#highScoresTable {
      margin: 0 auto;
      border-collapse: collapse;
      width: 80%;
      max-width: 600px;
      background: rgba(0,0,0,0.45);
      border-radius: 8px;
      overflow: hidden;
    }
    table#highScoresTable th, table#highScoresTable td {
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      font-size: 1em;
    }
    table#highScoresTable th {
      background: rgba(255,255,255,0.12);
      font-weight: normal;
    }
    table#highScoresTable tr:last-child td {
      border-bottom: none;
    }
    /* General Styles */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Bungee', sans-serif;
      text-align: center;
      background: #000;
    }
    /* Text Shadow for better legibility */
    body, h1, h2, h3, h4, h5, h6, p, span, div {
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
    }
    /* Main Game Container */
    #appContainer {
      position: relative;
      width: 100%;
      height: 100%;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      overflow: hidden;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    /* Title Styling */
    .title {
      font-size: 5em; 
      margin-bottom: 20px;
      line-height: 1.3;
    }
    /* Mode Text */
    .mode-text {
      font-size: 5em;
      line-height: 1.2;
      margin: 20px;
    }
    /* Ensure overlayed UI sits above background video */
    .overlay {
      position: relative;
      z-index: 2;
      width: 100%;
    }
    .mode-text { /* reinforce stacking for mode label */
      position: relative;
      z-index: 2;
    }
    /* Buttons */
    .play-button, .end-button {
      background: rgba(0, 0, 0, 0.7);
      border: none;
      padding: 1em 2em;
      color: #fff;
      font-size: 0.9em;
      cursor: pointer;
      border-radius: 8px;
      margin-top: 10px;
    }
    .play-button:hover, .end-button:hover {
      background: rgba(0, 0, 0, 0.9);
    }
    .end-button {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.8em;
      z-index: 2;
    }
    /* Get Ready Screen Text */
    .get-ready-text {
      font-size: 5em;
      line-height: 1.4;
    }
    /* Score Display */
    #scoreDisplay {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 2em;
      color: #fff;
      z-index: 2;
    }
    /* Hide Video and Canvas */
    #cameraFeed, #cameraCanvas {
      display: none;
    }

    /* Timer Bar */
    #timerWrapper {
      position: absolute;
      top: 60px;
      left: 0;
      width: 100%;
      height: 30px;
      background: rgba(255, 255, 255, 0.18);
      border-radius: 8px;
      overflow: hidden;
      z-index: 2;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.35) inset;
    }
    #timerBar {
      position: absolute;
      left: 0; /* shrink from left->right (bar stays left-aligned as it shrinks) */
      top: 0;
      bottom: 0;
      width: 100%;
      background: #00aa00; /* will be updated dynamically */
      transition: width 0.25s linear;
    }
    #timerLabel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2em;
      color: #fff;
      z-index: 3;
      pointer-events: none;
    }
  </style>
</head>
<body>

  <!-- Background Music (Looped) -->
  <audio id="backgroundMusic" src="AdaKPoP.mp3" loop></audio>
  <!-- Override Music (Hidden) -->
  <audio id="overrideMusic" loop></audio>

  <!-- Hidden Video for Webcam Processing -->
  <video id="cameraFeed" autoplay playsinline></video>
  <!-- Hidden Canvas for Processing Frames -->
  <canvas id="cameraCanvas" width="320" height="240"></canvas>

  <!-- Main Game Container -->
  <div id="appContainer"></div>
  <!-- Score Display -->
  <div id="scoreDisplay">Score: 0</div>

  <script>
    // -----------------------------
    //       GLOBAL VARIABLES
    // -----------------------------
    let isGameRunning = false;
    let highScore = 0;
    let activeTimeouts = [];
    let currentMode = null;
    let timedInterval = null;
    let timeLeft = 0;
    let bedModePreventCount = 0;  // to limit Bed Mode frequency
    let audioContext = null;
    let lastModeIndex = -1;
    const backgroundMusic = document.getElementById('backgroundMusic');
    const overrideMusic = document.getElementById('overrideMusic');

    // Variables for Camera-Based Scoring
    let mediaStream = null;
    let cameraInterval = null;
    let prevFrame = null;
    let score = 0;
    let lastScoreTime = 0; // For 2-second cooldown

    // High score storage (persisted in localStorage)
    let highScores = [];
    const HS_KEY = 'dtfHighScores';

    // -----------------------------
    //         GAME MODES
    // -----------------------------
    // Note: BAT MODE now uses a looping video (batmode.mp4) and no fallback image.
    const modes = [
      { name: 'HAND MODE', color: '#FF3333', backgroundImage: '', backgroundVideo: 'dancingcakes.mp4', overrideMusicUrl: '', minDuration: 15000, maxDuration: 25000, weight: 5 },
      { name: 'KICK MODE', color: '#33CC33', backgroundImage: 'kickmode.png', backgroundVideo: '', overrideMusicUrl: '', minDuration: 15000, maxDuration: 25000, weight: 5 },
    <!-- { name: 'BAT MODE', color: '#3333FF', backgroundImage: '', backgroundVideo: 'batmode.mp4', overrideMusicUrl: 'batmode.mp3', minDuration: 25000, maxDuration: 31000, weight: 5 }, -->
      { name: 'HEAD MODE', color: '#FF9900', backgroundImage: 'headmode.png', backgroundVideo: '', overrideMusicUrl: '', minDuration: 10000, maxDuration: 10000, weight: 2 },
      { name: 'BED MODE', color: '#663399', backgroundImage: 'bedmode.png', backgroundVideo: '', overrideMusicUrl: 'bedmode.mp3', minDuration: 13000, maxDuration: 18000, weight: 4 },
      { name: 'ELBOW MODE', color: '#CC33CC', backgroundImage: 'elbowmode.png', backgroundVideo: '', overrideMusicUrl: '', minDuration: 9000, maxDuration: 13000, weight: 1 },
      { name: 'NOSE MODE', color: '#FFA500', backgroundImage: 'nosemode.png', backgroundVideo: '', overrideMusicUrl: 'nosemode.mp3', minDuration: 10000, maxDuration: 11000, weight: 2 }
    ];

    // Preload images to avoid flicker
    function preloadImages() {
      modes.forEach(mode => {
        if (mode.backgroundImage) {
          const img = new Image();
          img.src = mode.backgroundImage;
        }
      });
    }
    preloadImages();

    const appContainer = document.getElementById('appContainer');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const cameraFeed = document.getElementById('cameraFeed');
    const cameraCanvas = document.getElementById('cameraCanvas');
    const ctx = cameraCanvas.getContext('2d');

    // -----------------------------
    //       HIGH SCORE HELPERS
    // -----------------------------
    function loadHighScores() {
      try {
        const raw = localStorage.getItem(HS_KEY);
        highScores = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(highScores)) highScores = [];
      } catch (e) {
        highScores = [];
      }
    }

    function saveHighScores() {
      try {
        localStorage.setItem(HS_KEY, JSON.stringify(highScores));
      } catch (e) {
        // ignore storage errors
      }
    }

    function addHighScore(name, score) {
      highScores.push({ name: name || 'Player', score: Number(score) || 0, ts: Date.now() });
      // Sort desc by score, then earlier timestamp first (stable-ish)
      highScores.sort((a,b) => b.score - a.score || a.ts - b.ts);
      // Keep only top 50 stored
      highScores = highScores.slice(0, 50);
      saveHighScores();
    }

    function getTopHighScores(n=5) {
      return highScores.slice(0, n);
    }

    function renderHighScoreTable(containerEl) {
      containerEl.innerHTML = '';
      if (!highScores.length) return; // nothing to render
      const top = getTopHighScores(5);
      const wrapper = document.createElement('div');
      wrapper.id = 'highScoresWrapper';
      wrapper.innerHTML = `
        <h3>High Scores</h3>
        <table id="highScoresTable">
          <thead>
            <tr><th style="text-align:left;">Player</th><th style="text-align:right;">Score</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      `;
      containerEl.appendChild(wrapper);
      const tbody = wrapper.querySelector('tbody');
      top.forEach((row, idx) => {
        const tr = document.createElement('tr');
        const nameCell = document.createElement('td');
        const scoreCell = document.createElement('td');
        nameCell.style.textAlign = 'left';
        scoreCell.style.textAlign = 'right';
        const star = idx === 0 ? 'â˜… ' : '';
        nameCell.textContent = star + row.name;
        scoreCell.textContent = row.score;
        tr.appendChild(nameCell);
        tr.appendChild(scoreCell);
        tbody.appendChild(tr);
      });
    }

    // Load scores initially
    loadHighScores();

    // -----------------------------
    //       CLEAR SCORES BUTTON
    // -----------------------------
    function clearHighScores() {
      if (!confirm('Clear all saved scores?')) return;
      highScores = [];
      try { localStorage.removeItem(HS_KEY); } catch (e) {}
      // Refresh any visible score tables
      const hsHome = document.getElementById('hsContainer');
      if (hsHome) renderHighScoreTable(hsHome);
      const hsFinal = document.getElementById('hsContainerFinal');
      if (hsFinal) renderHighScoreTable(hsFinal);
      const postSave = document.getElementById('postSaveHS');
      if (postSave) renderHighScoreTable(postSave);
    }

    // -----------------------------
    //       HELPER FUNCTIONS
    // -----------------------------
    function clearAllTimeouts() {
      activeTimeouts.forEach(id => clearTimeout(id));
      activeTimeouts = [];
    }

    function getModeDuration(mode) {
      const min = mode.minDuration;
      const max = mode.maxDuration;
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function pickWeightedMode() {
      let candidateModes = modes.map((m, idx) => ({ ...m, idx }));

      // Exclude the previously used mode if there's more than one
      if (lastModeIndex !== -1 && candidateModes.length > 1) {
        candidateModes = candidateModes.filter(m => m.idx !== lastModeIndex);
      }

      // If bedModePreventCount is active, exclude BED MODE
      if (bedModePreventCount > 0) {
        candidateModes = candidateModes.filter(m => m.name !== 'BED MODE');
      }

      // Weighted random selection
      const totalWeight = candidateModes.reduce((sum, m) => sum + m.weight, 0);
      let rand = Math.random() * totalWeight;
      let chosenMode = candidateModes[candidateModes.length - 1]; // fallback

      for (let mode of candidateModes) {
        if (rand < mode.weight) {
          chosenMode = mode;
          break;
        }
        rand -= mode.weight;
      }

      // If chosen mode is BED MODE, set bedModePreventCount to 3
      if (chosenMode.name === 'BED MODE') {
        bedModePreventCount = 3;
      } else if (bedModePreventCount > 0) {
        // Otherwise, if we have a cooldown going, decrement it
        bedModePreventCount--;
      }

      return chosenMode;
    }

    // -----------------------------
    //       SCREEN FUNCTIONS
    // -----------------------------
    function showHomeScreen() {
      clearAllTimeouts();
      // Stop any playing music
      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;
      overrideMusic.pause();
      overrideMusic.src = "";
      // Stop webcam processing
      stopCameraProcessing();
      // Reset score
      score = 0;
      scoreDisplay.textContent = `Score: ${score}`;
      appContainer.style.backgroundColor = '#FF00AA';
      appContainer.style.backgroundImage = 'none';
      appContainer.innerHTML = `
        <div class="title">Don't Touch The Floor!</br>ðŸŽ‚ Ada's 5th Birthday ðŸŽ‚</div>
        <div>
          <button class="play-button" onclick="startTimedGame()">Play Timed Mode (3 min)</button>
          <button class="play-button" style="margin-left:10px; background: rgba(255,0,0,0.35);" onclick="clearHighScores()">Clear scores</button>
        </div>
        <div id="hsContainer"></div>
      `;
      // If there are saved scores, render the table
      const hsContainer = document.getElementById('hsContainer');
      renderHighScoreTable(hsContainer);
    }

    function showGetReadyScreen(callback) {
  playGetReadyBeep();
  // Pick a new mode before we show it
  currentMode = pickWeightedMode();
  lastModeIndex = currentMode.idx;
      appContainer.style.backgroundColor = '#000';
      appContainer.style.backgroundImage = 'none';
      appContainer.innerHTML = `
        <button class="end-button" onclick="endGame()">END GAME</button>
        <div class="get-ready-text">GET READY!</div>
      `;
      const t = setTimeout(callback, 4000);
      activeTimeouts.push(t);
    }

    function showModeScreen() {
      if (!isGameRunning) return;
      // lastModeIndex was set above, so just remove the extra line picking a new mode
      const chosenMode = currentMode;
      
      // For video override: if backgroundVideo exists, set container background to transparent.
      if (chosenMode.backgroundVideo) {
        appContainer.style.backgroundColor = "transparent";
        appContainer.style.backgroundImage = 'none';
      } else if (chosenMode.backgroundImage) {
        appContainer.style.backgroundColor = 'transparent';
        appContainer.style.backgroundImage = `url('${chosenMode.backgroundImage}')`;
      } else {
        appContainer.style.backgroundImage = 'none';
        appContainer.style.backgroundColor = chosenMode.color;
      }

      // Play ding ding sound
      playDingDing();

      // Override music handling
      if (chosenMode.overrideMusicUrl) {
        backgroundMusic.pause();
        overrideMusic.pause();
        overrideMusic.src = chosenMode.overrideMusicUrl;
        overrideMusic.play().catch(err => console.warn("Override music error:", err));
      } else {
        if (backgroundMusic.paused) {
          backgroundMusic.play().catch(err => console.warn("Background music error:", err));
        }
      }

      // Build the background element.
      let backgroundElement = '';
      if (chosenMode.backgroundVideo) {
        backgroundElement = `
          <video autoplay loop muted playsinline preload="auto" style="position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; z-index:0; pointer-events:none;">
            <source src="${chosenMode.backgroundVideo}" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
        `;
      }
      
      // Wrap overlay content in a container with higher z-index.
      const overlayContent = `
        <div class="overlay">
          <button class="end-button" onclick="endGame()">END GAME</button>
          <div class="mode-text">${chosenMode.name}</div>
        </div>
      `;
      
      appContainer.innerHTML = backgroundElement + overlayContent;
      
      // After the mode duration, transition back.
      const duration = getModeDuration(chosenMode);
      const t = setTimeout(() => {
        if (isGameRunning) {
          // Stop override music if playing
          if (overrideMusic && !overrideMusic.paused) {
            overrideMusic.pause();
            overrideMusic.src = "";
          }
          if (backgroundMusic.paused) {
            backgroundMusic.play().catch(err => console.warn("Background music error:", err));
          }
          showGetReadyScreen(showModeScreen);
        }
      }, duration);
      activeTimeouts.push(t);
    }

    function cycleModes() {
      showGetReadyScreen(showModeScreen);
    }

    // -----------------------------
    //       CAMERA FUNCTIONS
    // -----------------------------
    async function startCameraProcessing() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn("Camera not supported.");
        return;
      }
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        cameraFeed.srcObject = mediaStream;
        await new Promise(resolve => setTimeout(resolve, 500));
        cameraInterval = setInterval(detectMotionAndScore, 500);
      } catch (err) {
        console.error("Error accessing webcam:", err);
      }
    }

    function stopCameraProcessing() {
      if (cameraInterval) {
        clearInterval(cameraInterval);
        cameraInterval = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
      prevFrame = null;
    }

  function showFloatingText(text, color) {
    const floatElem = document.createElement('div');
    floatElem.style.position = 'absolute';
    floatElem.style.top = '60%';
    floatElem.style.left = '50%';
    floatElem.style.transform = 'translateX(-50%)';
    floatElem.style.fontSize = '4em';
    floatElem.style.color = color;
    floatElem.style.opacity = '1';
    floatElem.innerHTML = text;
    appContainer.appendChild(floatElem);

    setTimeout(() => {
      floatElem.style.transition = 'opacity 2s ease-out';
      floatElem.style.opacity = '0';
    }, 50);

    setTimeout(() => {
      if (floatElem.parentNode) {
        floatElem.parentNode.removeChild(floatElem);
      }
    }, 2050);
  }

    function detectMotionAndScore() {
      const w = cameraCanvas.width;
      const h = cameraCanvas.height;
      ctx.drawImage(cameraFeed, 0, 0, w, h);
      const currentFrame = ctx.getImageData(0, 0, w, h);
      if (prevFrame) {
        let topDiff = 0, bottomDiff = 0;
        for (let i = 0; i < currentFrame.data.length; i += 4) {
          const y = Math.floor((i / 4) / w);
          const diff = Math.abs(currentFrame.data[i] - prevFrame.data[i]) +
                       Math.abs(currentFrame.data[i+1] - prevFrame.data[i+1]) +
                       Math.abs(currentFrame.data[i+2] - prevFrame.data[i+2]);
          if (diff > 50) {
            if (y < h / 2) topDiff++;
            else bottomDiff++;
          }
        }
        if (topDiff > bottomDiff * 1.5 && topDiff > 100) {
          const now = performance.now();
          if (now - lastScoreTime >= 2000) {
            if (currentMode && currentMode.name === 'BED MODE') {
              score--;
              showFloatingText('-1', 'red');
            } else {
              score++;
              showFloatingText('+1', 'green');
            }
            scoreDisplay.textContent = `Score: ${score}`;
            lastScoreTime = now;
          }
        }
      }
      prevFrame = currentFrame;
    }

    // -----------------------------
    //       AUDIO FUNCTIONS
    // -----------------------------
    function playGetReadyBeep() {
      if (!audioContext) return;
      const now = audioContext.currentTime;

      // Create an oscillator for a short beep
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.frequency.value = 440; // A4 note
      oscillator.type = 'sine';
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // Set volume
      gainNode.gain.setValueAtTime(0.3, now);

      oscillator.start(now);
      oscillator.stop(now + 0.5); // beep lasts 0.5 seconds
    }
    
    
    function playDingDing() {
      if (!audioContext) return;
      const now = audioContext.currentTime;
      let beepTime = now;
      for (let i = 0; i < 2; i++) {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.frequency.value = 880; // A5 note
        oscillator.type = 'sine';
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        gainNode.gain.setValueAtTime(0.3, now);
        oscillator.start(beepTime);
        oscillator.stop(beepTime + 0.2);
        beepTime += 0.3;
      }
    }

    // -----------------------------
    //       GAME CONTROL
    // -----------------------------
    function startGame() {
      if (!audioContext) {
        audioContext = new AudioContext();
      }
      clearAllTimeouts();
      isGameRunning = true;
      backgroundMusic.currentTime = 0;
      backgroundMusic.volume = 1.0;
      backgroundMusic.play().catch(err => console.warn("Background music error:", err));
      startCameraProcessing();
      cycleModes();
    }

    function endGame() {
      isGameRunning = false;
      clearAllTimeouts();
      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;
      overrideMusic.pause();
      overrideMusic.src = "";
      stopCameraProcessing();

      // Remove timer UI and clear interval
      if (timedInterval) {
        clearInterval(timedInterval);
        timedInterval = null;
      }
      const timerWrapper = document.getElementById('timerWrapper');
      if (timerWrapper && timerWrapper.parentNode) {
        timerWrapper.parentNode.removeChild(timerWrapper);
      }

      // Show score entry UI so the player can save their score
      showScoreEntry();
    }

    function showScoreEntry() {
      appContainer.style.backgroundColor = '#000';
      appContainer.style.backgroundImage = 'none';
      const defaultName = '';
      appContainer.innerHTML = `
        <div style="color:#fff; font-size:2.2em; margin-top: 10vh;">You scored: ${score}</div>
        <div style="margin-top: 20px; color:#fff;">Enter your team name to save your score:</div>
        <div style="margin-top: 10px;">
          <input id="playerNameInput" type="text" maxlength="32" placeholder="Team name" value="${defaultName}" style="padding:10px 12px; font-size:1.1em; border-radius:6px; border:none; width:280px; text-align:center;" />
        </div>
        <div style="margin-top: 12px;">
          <button class="play-button" id="saveScoreBtn">Save Score</button>
          <button class="end-button" style="position:static; margin-left:10px;" id="skipBtn">Skip</button>
        </div>
        <div id="postSaveHS" style="margin-top: 20px;"></div>
      `;
      const saveBtn = document.getElementById('saveScoreBtn');
      const skipBtn = document.getElementById('skipBtn');
      const nameInput = document.getElementById('playerNameInput');
      const postSaveHS = document.getElementById('postSaveHS');

      function finish(save) {
        if (save) {
          const name = (nameInput.value || 'Player').trim();
          addHighScore(name, score);
          renderHighScoreTable(postSaveHS);
        }
        // Also refresh the home screen table when we go back
        const t = setTimeout(() => {
          showHighScoreScreen();
        }, 1500);
        activeTimeouts.push(t);
      }

      saveBtn.addEventListener('click', () => finish(true));
      skipBtn.addEventListener('click', () => finish(false));
    }

    function showHighScoreScreen() {
      appContainer.style.backgroundColor = '#000';
      appContainer.style.backgroundImage = 'none';
      appContainer.innerHTML = `
        <div style="color: white; font-size: 3em; margin-top: 12vh;">You scored: ${score}</div>
        <div id="hsContainerFinal" style="margin-top: 16px;"></div>
        <div style="margin-top: 10px;">
          <button class="play-button" onclick="showHomeScreen()">Back to Home</button>
          <button class="play-button" style="margin-left:10px; background: rgba(255,0,0,0.35);" onclick="clearHighScores()">Clear scores</button>
        </div>
      `;
      const hsFinal = document.getElementById('hsContainerFinal');
      renderHighScoreTable(hsFinal);
      const t = setTimeout(showHomeScreen, 6000);
      activeTimeouts.push(t);
    }

    // Timed Game function (3 minutes)
    function startTimedGame() {
  if (!audioContext) {
    audioContext = new AudioContext();
  }
  clearAllTimeouts();
  isGameRunning = true;
  backgroundMusic.currentTime = 0;
  backgroundMusic.volume = 1.0;
  backgroundMusic.play().catch(err => console.warn("Background music error:", err));
  startCameraProcessing();
  cycleModes();

  // Remove any previous timer UI
  const oldWrapper = document.getElementById('timerWrapper');
  if (oldWrapper && oldWrapper.parentNode) oldWrapper.parentNode.removeChild(oldWrapper);

  // Build timer bar UI
  const wrapper = document.createElement('div');
  wrapper.id = 'timerWrapper';
  const bar = document.createElement('div');
  bar.id = 'timerBar';
  const label = document.createElement('div');
  label.id = 'timerLabel';
  wrapper.appendChild(bar);
  wrapper.appendChild(label);
  document.body.appendChild(wrapper);

  // Initialize countdown to 180 seconds = 3 minutes
  const totalTime = 180;
  timeLeft = totalTime;

  function setBarState() {
    const ratio = Math.max(0, Math.min(1, timeLeft / totalTime));
    // Shrink while staying left-aligned via width percentage
    bar.style.width = (ratio * 100).toFixed(2) + '%';
    // Smooth colour shift green -> red as time runs out
    const r = Math.round(255 * (1 - ratio));
    const g = Math.round(255 * ratio);
    bar.style.background = `rgb(${r}, ${g}, 0)`;
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    label.textContent = `Time Left: ${minutes}:${String(seconds).padStart(2, '0')}`;
  }

  function updateTimer() {
    if (!isGameRunning || timeLeft <= 0) {
      clearInterval(timedInterval);
      timedInterval = null;
      return;
    }
    timeLeft--;
    setBarState();
  }

  // First paint
  setBarState();

  // Tick once per second
  if (timedInterval) clearInterval(timedInterval);
  timedInterval = setInterval(updateTimer, 1000);

  // End game after exactly 3 minutes
  const endTimer = setTimeout(() => {
    if (isGameRunning) {
      endGame();
    }
  }, totalTime * 1000);
  activeTimeouts.push(endTimer);
    }

    function endGameOLD() {

    }

    // -----------------------------
    //       INITIALIZE
    // -----------------------------
    showHomeScreen();
  </script>

</body>
</html>